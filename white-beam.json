{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"noiseFill","usesPingPong":false,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"38291440-85a8-4cf0-be65-36de41995a25","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;vec3 hash33(vec3 p3) {\np3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\np3 += dot(p3, p3.yxz + 19.19);\nreturn -1.0 + 2.0 * fract(vec3(\n(p3.x + p3.y) * p3.z,\n(p3.x + p3.z) * p3.y,\n(p3.y + p3.z) * p3.x\n));\n}float perlin_noise(vec3 p) {\nvec3 pi = floor(p);\nvec3 pf = p - pi;vec3 w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0)));\nfloat n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0)));\nfloat n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0, 1.0, 0.0)));\nfloat n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0)));\nfloat n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0)));\nfloat n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0)));\nfloat n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0)));\nfloat n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x);\nfloat nx01 = mix(n001, n101, w.x);\nfloat nx10 = mix(n010, n110, w.x);\nfloat nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y);\nfloat nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz;\n}vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn (src + dst) - 1.0;\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TAU = 6.28318530718;vec3 anchoredPal(float t, vec3 col1, vec3 col2) {\nvec3 mid = 0.5 * (col1 + col2);\nvec3 axisAmp = 0.5 * (col2 - col1);vec3 base = mid + axisAmp * cos(TAU * t);vec3 axis = length(axisAmp) > 0.0001 ? normalize(axisAmp) : vec3(1.0, 0.0, 0.0);\nvec3 ref = abs(axis.x) > 0.9 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\nvec3 tangent1 = normalize(cross(axis, ref));\nvec3 tangent2 = normalize(cross(axis, tangent1));float richness = 0.24 * length(axisAmp) + 0.02;\nvec3 ripple =\ntangent1 * sin(TAU * (t * 2.0 + 0.123)) +\ntangent2 * sin(TAU * (t * 3.0 + 0.437));vec3 col = base + (richness * 0.0000) * ripple;\ncol = 1./(1. + exp(-col * 4. + 0.25) * 7.5);\nreturn col;\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}float getPerlinNoise(vec2 uv) {\nfloat turb = 0.8000 * 3.2;\nvec2 skew = vec2(0.9600, 1. - 0.9600);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125) * mix(1., 14., 15.0000);\nfloat noise = perlin_noise(vec3(\nuv * skew - drift,\n0.0000 + uTime * 0.03\n));return mix(0.5, noise * 0.5 + 0.5, turb);\n}float getNoise(vec2 uv) {\nreturn getPerlinNoise(uv);\n}void main() {\nvec2 uv = vTextureCoord;\nfloat aspectRatio = uResolution.x/uResolution.y;\nvec2 aspect = vec2(aspectRatio, 1.0);vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);vec2 pos = mix(vec2(0.5, 0.5), mPos, 0.0000);\nfloat scale = mix(1., 14., 15.0000);\nvec2 drift = vec2(0, 0.0000 * uTime * 0.0125);\nmat2 rotation = rot(-0.2500 * 2. * PI);vec2 st = (uv - pos) * aspect * scale * rotation;\nfloat noise = getNoise(st);if (0.0000 > 0.0) {\nvec2 toMouse = (uv - uMousePos) * aspect;\nfloat r = length(toMouse);\nfloat radius = mix(0.1, 1., 0.5000);\nfloat falloff = 1.0 - smoothstep(0.0, radius, r);\nvec2 dir = toMouse / max(r, 1e-5);\nvec2 uvBulgeOffsetAspect = -dir * (0.0000 * radius) * falloff * falloff;\nvec2 offset = uvBulgeOffsetAspect / aspect * r * 5.;st = (uv - pos + offset * noise) * aspect * scale * rotation;\nnoise = getNoise(st);\n}vec4 color = texture(uTexture, uv);\nvec4 bg = color;\nfloat shift = 0.5000 + (0.0000 * uTime * 0.01);\nvec3 noiseColor = anchoredPal(noise + shift, vec3(1, 1, 1), vec3(0, 0, 0));\ncolor.rgb = noiseColor.rgb;float dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;\ncolor.rgb += dither * 0.5;color.rgb = blend(10, bg.rgb, color.rgb);color.rgb = mix(bg.rgb, color.rgb, 1.0000);\ncolor.a = max(bg.a, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect1"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"beam","usesPingPong":false,"skew":0,"mix":1,"speed":0.25,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"states":{"appear":[{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"bf691844-2985-4df0-908e-e3b2974c305a","prop":"skew","transition":{"delay":1000,"duration":1000,"ease":"s=>1-Math.pow(1-s,5)"},"complete":false,"progress":0,"value":0.5,"endValue":0,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uSkew"}},{"local":{"pendingChanges":{},"changeDebouncer":null,"dragSession":null},"type":"appear","id":"363217be-f50b-45d9-876b-4723c9051b37","prop":"mix","transition":{"ease":"s=>1-Math.pow(1-s,5)","duration":1000,"delay":1000},"complete":false,"progress":0,"value":0,"endValue":1,"initialized":false,"breakpoints":[],"loop":"none","loopDelay":0,"uniformData":{"type":"1f","name":"uMix"}}],"scroll":[],"hover":[]},"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nprecision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uSkew;\nuniform float uMix;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}uvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}vec3 Tonemap_tanh(vec3 x) {\nx = clamp(x, -40.0, 40.0);\nreturn (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}out vec4 fragColor;const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;float luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}mat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec3 drawPoint(vec2 uv, vec2 center, float scale) {\nuv.x *= uResolution.x/uResolution.y;\ncenter.x *= uResolution.x/uResolution.y;\nvec2 skew = vec2(uSkew, 1. - uSkew) * 2.;\nuv = uv * rot(0.0000 * TWO_PI) * skew;\ncenter = center * rot(0.0000 * TWO_PI) * skew;\nfloat dist = distance(uv, center);\nfloat radius = scale * 0.25;float brightness = radius / dist;\nbrightness = mix(brightness, brightness*brightness, 0.0100);\nreturn brightness * vec3(1, 1, 1);\n}vec3 getBeam(vec2 uv) {\nvec2 pos = vec2(0, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nreturn drawPoint(uv, pos, 0.1000);\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv);\nfloat dither = (randFibo(gl_FragCoord.xy) - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb);\nvec3 result = mix(bg.rgb, blended, uMix);\nresult += dither;vec4 color = vec4(result, max(bg.a, luma(beam)));\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect2"},{"breakpoints":[],"visible":true,"locked":false,"aspectRatio":1.6,"layerName":"","userDownsample":1,"isElement":true,"opacity":1,"effects":["38291440-85a8-4cf0-be65-36de41995a25","98fcb7b1-32a7-46a9-be6f-9e506ae1bdf4"],"displace":0,"trackMouse":0,"anchorPoint":"center","mouseMomentum":0,"blendMode":"COLOR_DODGE","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"image","imageLoaded":false,"width":1.2,"widthMode":"relative","height":0.8,"heightMode":"relative","left":0.5,"leftMode":"relative","top":0.5,"topMode":"relative","rotation":0,"trackAxes":"xy","fitToCanvas":0,"exposure":0,"saturation":1,"contrast":1,"src":"https://assets.unicorn.studio/images/h45ZcUrKKoQOQBOsjFtZENL3g052/remix_HD%20HR%20Texture.webp","naturalWidth":1440,"naturalHeight":900,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform int uSampleBg;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((src.x == 1.0) ? 1.0 : min(1.0, dst.x / (1.0 - src.x)), (src.y == 1.0) ? 1.0 : min(1.0, dst.y / (1.0 - src.y)), (src.z == 1.0) ? 1.0 : min(1.0, dst.z / (1.0 - src.z)));\n}const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(8, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);color.rgb = clamp(color.rgb, 0.0, 1.0) * color.a;vec4 col = getOutputByMode(color, background);fragColor = col;\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{}},"id":"image"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"sine","usesPingPong":false,"speed":0,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;\nuniform sampler2D uTexture;\nuniform float uTime;\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\nfloat ease (int easingFunc, float t) {\nreturn t;\n}\nout vec4 fragColor;const float PI = 3.141592;void main() {\nvec2 uv = vTextureCoord;\nvec2 waveCoord = vTextureCoord.xy * 2.0 - 1.0;\nfloat thirdPI = PI * 0.3333;\nfloat time = uTime * 0.25;\nfloat frequency = 20.0 * 0.1600;\nfloat amp = 1.0000 * 0.2;float waveX = sin((waveCoord.y + vec2(0.5, 0.5).y) * frequency + (time * thirdPI)) * amp;\nfloat waveY = sin((waveCoord.x - vec2(0.5, 0.5).x) * frequency + (time * thirdPI)) * amp;\nwaveCoord.xy += vec2(mix(waveX, 0., 0.8400), mix(0., waveY, 0.8400));vec2 finalUV = waveCoord * 0.5 + 0.5;\nfloat aspectRatio = uResolution.x/uResolution.y;vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nvec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000));\nfloat dist = ease(0, max(0.,1.-distance(uv * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));if (0 == 1) {\ndist = max(0., (0.5 - dist));\n}\nuv = mix(uv, finalUV, dist);vec4 color = texture(uTexture, uv);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"projection","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"parentLayer":"98fcb7b1-32a7-46a9-be6f-9e506ae1bdf4","animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) {\nvec2 screenPos = (uv - 0.5) * 2.0;\nscreenPos.x *= aspect;\nscreenPos.y *= -1.0;\nfloat minFOV = radians(20.0);\nfloat maxFOV = radians(120.0);\nfloat fov = mix(minFOV, maxFOV, 0.0000);\nvec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0),\nscreenPos.y * tan(fov/2.0),\n-1.0));\nfloat rotX = (mousePos.y - 0.5) * PI;\nfloat rotY = (mousePos.x - 0.5) * PI * 2.0;\nmat3 rotateY = mat3(\ncos(rotY), 0.0, -sin(rotY),\n0.0, 1.0, 0.0,\nsin(rotY), 0.0, cos(rotY)\n);\nmat3 rotateX = mat3(\n1.0, 0.0, 0.0,\n0.0, cos(rotX), sin(rotX),\n0.0, -sin(rotX), cos(rotX)\n);\nreturn normalize(rotateX * rotateY * rayDir);\n}vec2 directionToUVHorizontal(vec3 dir) {\nfloat longitude = atan(dir.z, dir.x);\nfloat latitude = acos(dir.y);\nvec2 uv;\nuv.x = longitude / (2.0 * PI) + 0.5;\nuv.y = latitude / PI;\nuv.x += 0.25;\nreturn uv;\n}vec2 directionToUVVertical(vec3 dir) {\nfloat longitude = atan(dir.z, dir.y);\nfloat latitude = acos(dir.x);\nvec2 uv;\nuv.y = longitude / PI * -1.;\nuv.x = (latitude / (2.0 * PI) + 0.5) * -1.;\nuv.x = fract(uv.x + 0.25);\nreturn uv;\n}out vec4 fragColor;vec4 getRepeatHorizontalUV(vec2 uv) {\nvec2 finalUV = vec2(fract(uv.x), uv.y);\nvec4 col = texture(uTexture, finalUV);\nif (0.6400 > 0.0) {\nfloat blendWidth = 0.6400 * 0.1;\nfloat blendFactor = 0.0;\nif (finalUV.x < blendWidth) {\nblendFactor = 1.0 - (finalUV.x / blendWidth);\n} else if (finalUV.x > 1.0 - blendWidth) {\nblendFactor = (finalUV.x - (1.0 - blendWidth)) / blendWidth;\n}\nif (blendFactor > 0.0) {\nblendFactor = smoothstep(0.0, 1.0, blendFactor);\nvec2 oppositeUV = vec2(finalUV.x > 0.5 ? finalUV.x - 0.5 : finalUV.x + 0.5, finalUV.y);\nvec4 oppositeCol = texture(uTexture, oppositeUV);\ncol = mix(col, oppositeCol, blendFactor);\n}\n}\nreturn col;\n}vec4 getRepeatUV(vec2 uv) {\nreturn getRepeatHorizontalUV(uv);\n}void main() {\nfloat aspect = 2.;\nvec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000 * 0.5);\nvec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect);\nvec2 uvHorizontal = directionToUVHorizontal(rayDir);\nvec2 uvVertical = directionToUVVertical(rayDir);\nvec2 sphereUV = mix(uvHorizontal, uvVertical, 0.0000);\nfloat minFOV = radians(20.0);\nfloat maxFOV = radians(120.0);\nfloat currentFOV = mix(minFOV, maxFOV, 0.0000);\nfloat fovCompensation = tan(currentFOV/2.0);\nfloat compensatedScale = (mix(-0.1, 0.4, 0.2100) * 12.0 + 2.0) * (1.0/fovCompensation);\nsphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(-0.2, 0) * uTime * 0.005;vec4 col = getRepeatUV(sphereUV);\nfragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"}],"options":{"name":"White Beam","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false},"version":"1.5.2","id":"2KPYPU3R48OZRaCjrItn"}